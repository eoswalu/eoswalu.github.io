<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JMHS Class of 2028 Rankings</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a1a;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: #2a2a2a;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.5);
            overflow: hidden;
        }

        .header {
            background: #000000;
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            font-weight: 700;
        }

        .main-content {
            padding: 30px;
            background: #2a2a2a;
        }

        .tier-container {
            margin-bottom: 30px;
        }

        .tier-row {
            display: flex;
            margin-bottom: 15px;
            min-height: 80px;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            transition: transform 0.2s ease;
        }

        .tier-row:hover {
            transform: translateY(-2px);
        }

        .tier-label {
            width: 120px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 1.5rem;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .tier-s { background: linear-gradient(135deg, #ff7f7f, #ff5f5f); color: #000; }
        .tier-a { background: linear-gradient(135deg, #ffbf7f, #ff9f5f); color: #000; }
        .tier-b { background: linear-gradient(135deg, #ffdf7f, #ffcf5f); color: #000; }
        .tier-c { background: linear-gradient(135deg, #ffff7f, #ffff5f); color: #000; }
        .tier-d { background: linear-gradient(135deg, #bfff7f, #afff5f); color: #000; }

        .tier-items {
            flex: 1;
            background: #3a3a3a;
            min-height: 80px;
            display: flex;
            align-items: center;
            padding: 10px;
            gap: 10px;
            flex-wrap: wrap;
            border: 2px dashed #555;
            transition: all 0.3s ease;
            position: relative;
        }

        .tier-items.drag-over {
            background: #4a4a4a;
            border-color: #777;
            transform: scale(1.02);
        }

        .name-pool {
            background: #3a3a3a;
            border: 2px dashed #555;
            border-radius: 10px;
            padding: 20px;
            padding-top: 100px;
            min-height: 200px;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-content: flex-start;
            position: relative;
        }

        .name-pool-header {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            gap: 15px;
            z-index: 1;
        }

        .name-item {
            background: linear-gradient(135deg, #666666, #444444);
            color: white;
            padding: 8px 16px;
            border-radius: 15px;
            cursor: move;
            user-select: none;
            transition: all 0.3s ease;
            font-weight: 500;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            border: 1px solid #888;
            position: relative;
            z-index: 1;
        }

        .name-item:hover {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 8px 25px rgba(255, 255, 255, 0.1);
            background: linear-gradient(135deg, #777777, #555555);
        }

        .name-item:active {
            transform: scale(0.95);
        }

        .name-item.glow-left {
            box-shadow: -5px 0 20px rgba(0, 255, 65, 0.8), -2px 0 8px rgba(0, 255, 65, 1), 0 4px 15px rgba(0, 0, 0, 0.3);
            transition: box-shadow 0.1s ease;
        }
        
        .name-item.glow-right {
            box-shadow: 5px 0 20px rgba(0, 255, 65, 0.8), 2px 0 8px rgba(0, 255, 65, 1), 0 4px 15px rgba(0, 0, 0, 0.3);
            transition: box-shadow 0.1s ease;
        }

        .name-item.dragging {
            opacity: 0.5;
            transform: rotate(5deg);
        }

        .name-item.dropped-glow {
            box-shadow: 0 0 20px rgba(0, 255, 65, 0.8), 0 0 8px rgba(0, 255, 65, 1), 0 4px 15px rgba(0, 0, 0, 0.3);
            transition: box-shadow 0.5s ease-out;
        }

        .controls {
            display: flex;
            gap: 15px;
            margin-bottom: 30px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #666666, #444444);
            color: white;
            border: 1px solid #888;
        }

        .btn-secondary {
            background: linear-gradient(135deg, #666666, #444444);
            color: white;
            border: 1px solid #888;
        }

        .btn-success {
            background: linear-gradient(135deg, #666666, #444444);
            color: white;
            border: 1px solid #888;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.2), 0 0 15px rgba(255, 255, 255, 0.3);
        }

        .btn:active {
            box-shadow: 0 4px 15px rgba(0,0,0,0.3), 0 0 20px rgba(255, 255, 255, 0.5);
        }

        @media (max-width: 768px) {
            .header h1 {
                font-size: 2rem;
            }
            
            .tier-label {
                width: 80px;
                font-size: 1.2rem;
            }
            
            .main-content {
                padding: 15px;
            }
            
            .controls {
                justify-content: center;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>JMHS Class of 2028 Rankings</h1>
        </div>
        
        <div class="main-content">
            <div class="controls">
                <button class="btn btn-primary" onclick="resetTiers()">Reset All</button>
                <button class="btn btn-secondary" onclick="shuffleNames()">Shuffle Names</button>
                <button class="btn btn-success" onclick="downloadImage()">Save as Image</button>
                <button class="btn btn-primary" onclick="clearAllData()">Clear All Data</button>
            </div>

            <div class="tier-container">
                <div class="tier-row">
                    <div class="tier-label tier-s">S</div>
                    <div class="tier-items" data-tier="S" ondrop="drop(event)" ondragover="allowDrop(event)"></div>
                </div>
                
                <div class="tier-row">
                    <div class="tier-label tier-a">A</div>
                    <div class="tier-items" data-tier="A" ondrop="drop(event)" ondragover="allowDrop(event)"></div>
                </div>
                
                <div class="tier-row">
                    <div class="tier-label tier-b">B</div>
                    <div class="tier-items" data-tier="B" ondrop="drop(event)" ondragover="allowDrop(event)"></div>
                </div>
                
                <div class="tier-row">
                    <div class="tier-label tier-c">C</div>
                    <div class="tier-items" data-tier="C" ondrop="drop(event)" ondragover="allowDrop(event)"></div>
                </div>
                
                <div class="tier-row">
                    <div class="tier-label tier-d">D</div>
                    <div class="tier-items" data-tier="D" ondrop="drop(event)" ondragover="allowDrop(event)"></div>
                </div>
            </div>

            <div class="name-pool" ondrop="drop(event)" ondragover="allowDrop(event)">
                <div class="name-pool-header">
                    <h3 style="margin: 0; color: #e0e0e0; font-size: 1.8rem;">2028s</h3>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script>
        const names = [
            "Nadia A", "Stacy A", "Mackenzie A", "Grace A", "Olivia A", "Odalis A", "Amreen A", 
            "Cammie B", "Stella B", "Nina B", "Brooke B", "Liza B", "Zahraa B", "Reece B", "Finley B",
            "Elena C", "Kimiya C", "Manaal C", "Nina C", "Lila C", "Dayana C",
            "Nelle D", "Sophia D", "Gabby D", "Alexia D", "Claire D", "Lucy D", "Kayla D", "Avrie D", "Vidhi D",
            "Caroline E", "Corrine E",
            "Olivia F", "Vaughn F",
            "Gresil G",
            "Ainsley H", "Olivia H", "Tina H", "Julia H", "Ava H", "Hoxanna H", "Giuliana H",
            "Ella J", "Tae J",
            "Jayde K", "Elizabeth K", "Kyndall K", "Vivian K",
            "Cara L", "Lilian L", "Alesia L", "Charlotte L", "Annabelle L",
            "Charlotte M", "Abby M", "Sophie M", "Arianna M", "Claudia M", "Amy M", "Isla M", "Mariela M", 
            "Julia M", "Etta M", "Vivienne M", "Gaby M", "Sienna M", "Piper M", "Kennedy M", "Lena M", "Sophia M",
            "Ella N", "Aashna N", "Ava N", "Jenny N", "Christina N",
            "Lindsey O",
            "Chessie P", "Makenna P", "Addison P", "Kelsey P", "Bella P", "Hannah P", "Grace P",
            "Aly Q",
            "Ashley R", "Angelina R", "Aviva R", "Sasha R", "Amaya R",
            "Alex S", "Worthy S", "Millie S", "Lily S", "Lauren S", "Carly S", "Olivia S", "Piper S", 
            "Emeylyn S", "Ebba S", "Reagan S", "Natalie S",
            "Joud T", "Eleanor T",
            "Anna V",
            "Campbell W", "Lucy W", "Scarlet W", "Acaica W", "Gabby W",
            "Vivienne Y"
        ];

        // localStorage keys
        const STORAGE_KEYS = {
            CUSTOM_NAMES: 'tierlist_custom_names',
            TIER_POSITIONS: 'tierlist_positions',
            ACTION_HISTORY: 'tierlist_action_history'
        };

        // Get custom names from localStorage
        let customNames = JSON.parse(localStorage.getItem(STORAGE_KEYS.CUSTOM_NAMES) || '[]');
        let actionHistory = JSON.parse(localStorage.getItem(STORAGE_KEYS.ACTION_HISTORY) || '[]');

        function getAllNames() {
            return [...names, ...customNames];
        }

        // Save data to localStorage
        function saveToLocalStorage() {
            localStorage.setItem(STORAGE_KEYS.CUSTOM_NAMES, JSON.stringify(customNames));
            localStorage.setItem(STORAGE_KEYS.ACTION_HISTORY, JSON.stringify(actionHistory));
            saveTierPositions();
        }

        function saveTierPositions() {
            const positions = {};
            
            // Save tier positions
            document.querySelectorAll('.tier-items').forEach(tierContainer => {
                const tier = tierContainer.dataset.tier;
                const names = [...tierContainer.querySelectorAll('.name-item')].map(item => item.textContent);
                positions[tier] = names;
            });
            
            // Save name pool positions
            const namePool = document.querySelector('.name-pool');
            const poolNames = [...namePool.querySelectorAll('.name-item')].map(item => item.textContent);
            positions['POOL'] = poolNames;
            
            localStorage.setItem(STORAGE_KEYS.TIER_POSITIONS, JSON.stringify(positions));
        }

        function loadTierPositions() {
            const saved = localStorage.getItem(STORAGE_KEYS.TIER_POSITIONS);
            if (!saved) return;
            
            try {
                const positions = JSON.parse(saved);
                
                // Clear all current positions
                document.querySelectorAll('.tier-items').forEach(container => {
                    container.innerHTML = '';
                });
                document.querySelector('.name-pool').querySelectorAll('.name-item').forEach(item => {
                    item.remove();
                });
                
                // Restore positions
                Object.entries(positions).forEach(([location, namesList]) => {
                    let container;
                    
                    if (location === 'POOL') {
                        container = document.querySelector('.name-pool');
                    } else {
                        container = document.querySelector(`[data-tier="${location}"]`);
                    }
                    
                    if (container) {
                        namesList.forEach(name => {
                            if (getAllNames().includes(name)) {
                                const nameElement = createNameElement(name);
                                container.appendChild(nameElement);
                            }
                        });
                    }
                });
                
            } catch (error) {
                console.error('Error loading tier positions:', error);
            }
        }

        // Initialize the page
        window.onload = function() {
            loadNames();
            loadTierPositions();
        };

        function allowDropOnDelete(event) {
            event.preventDefault();
            event.stopPropagation();
            const deleteBtn = event.currentTarget;
            deleteBtn.style.boxShadow = '0 0 20px rgba(255, 255, 255, 0.8), 0 0 30px rgba(255, 255, 255, 0.6)';
            deleteBtn.style.transform = 'scale(1.1)';
        }

        function removeDeleteHover(event) {
            const deleteBtn = event.currentTarget;
            deleteBtn.style.boxShadow = 'none';
            deleteBtn.style.transform = 'scale(1)';
        }

        function dropOnDelete(event) {
            event.preventDefault();
            event.stopPropagation();
            
            const data = event.dataTransfer.getData("text");
            const deleteBtn = event.currentTarget;
            
            // Remove hover effect
            deleteBtn.style.boxShadow = 'none';
            deleteBtn.style.transform = 'scale(1)';
            
            // Find and remove the dragged element
            const draggedElement = [...document.querySelectorAll('.name-item')]
                .find(item => item.textContent === data);
            
            if (draggedElement) {
                const nameText = draggedElement.textContent;
                
                // Add to action history for undo
                actionHistory.push({
                    type: 'delete',
                    name: nameText,
                    wasCustom: customNames.includes(nameText)
                });
                
                // Remove from custom names array if it's a custom name
                const customIndex = customNames.indexOf(nameText);
                if (customIndex > -1) {
                    customNames.splice(customIndex, 1);
                }
                
                // Remove the element from DOM
                draggedElement.remove();
                
                // Clean up any existing drag states
                document.querySelectorAll('.tier-items, .name-pool').forEach(item => {
                    item.classList.remove('drag-over');
                    item.querySelectorAll('.name-item').forEach(nameItem => {
                        nameItem.classList.remove('glow-left', 'glow-right');
                    });
                });
                
                // Save to localStorage
                saveToLocalStorage();
            }
        }

        function addNewName() {
            console.log("ADD button clicked!");
            
            // Create custom input dialog
            const inputDialog = document.createElement('div');
            inputDialog.style.cssText = 'position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #333; padding: 20px; border-radius: 10px; z-index: 10000; box-shadow: 0 0 20px rgba(0,0,0,0.8);';
            
            inputDialog.innerHTML = `
                <div style="color: white; margin-bottom: 15px; font-size: 16px;">Enter name(s):</div>
                <div style="color: #ccc; margin-bottom: 10px; font-size: 12px;">For multiple names, separate with " - " (e.g., "Anna B - Lauren A")</div>
                <input type="text" id="nameInput" style="width: 300px; padding: 8px; border-radius: 5px; border: 1px solid #666; background: #444; color: white; margin-bottom: 15px;">
                <div>
                    <button onclick="confirmAddName()" style="background: green; color: white; padding: 8px 15px; border: none; border-radius: 5px; margin-right: 10px; cursor: pointer;">Add</button>
                    <button onclick="cancelAddName()" style="background: red; color: white; padding: 8px 15px; border: none; border-radius: 5px; cursor: pointer;">Cancel</button>
                </div>
            `;
            
            document.body.appendChild(inputDialog);
            document.getElementById('nameInput').focus();
        }

        function confirmAddName() {
            const input = document.getElementById('nameInput');
            const inputText = input.value.trim();
            
            if (!inputText) {
                cancelAddName();
                return;
            }
            
            // Check if input contains dashes (multiple names)
            if (inputText.includes(' - ')) {
                // Split by " - " and process each name
                const namesList = inputText.split(' - ');
                let addedNames = [];
                let duplicateNames = [];
                
                namesList.forEach(name => {
                    const trimmedName = name.trim();
                    if (trimmedName && !getAllNames().includes(trimmedName)) {
                        customNames.push(trimmedName);
                        const nameElement = createNameElement(trimmedName);
                        const namePool = document.querySelector('.name-pool');
                        namePool.appendChild(nameElement);
                        addedNames.push(trimmedName);
                    } else if (trimmedName && getAllNames().includes(trimmedName)) {
                        duplicateNames.push(trimmedName);
                    }
                });
                
                // Add batch to action history
                if (addedNames.length > 0) {
                    actionHistory.push({
                        type: 'add',
                        names: addedNames
                    });
                    console.log(`${addedNames.length} names added successfully!`);
                    saveToLocalStorage();
                }
                
                if (duplicateNames.length > 0) {
                    alert(`These names already exist: ${duplicateNames.join(', ')}`);
                }
            } else {
                // Single name (original functionality)
                if (!getAllNames().includes(inputText)) {
                    customNames.push(inputText);
                    const nameElement = createNameElement(inputText);
                    const namePool = document.querySelector('.name-pool');
                    namePool.appendChild(nameElement);
                    
                    // Add to action history
                    actionHistory.push({
                        type: 'add',
                        names: [inputText]
                    });
                    console.log("Name added successfully!");
                    saveToLocalStorage();
                } else {
                    alert("This name already exists!");
                }
            }
            
            cancelAddName();
        }

        function cancelAddName() {
            const dialog = document.querySelector('div[style*="position: fixed"]');
            if (dialog) {
                dialog.remove();
            }
        }

        function undoDelete() {
            console.log("Undo button clicked!");
            console.log("Action history:", actionHistory);
            console.log("History length:", actionHistory.length);
            
            if (actionHistory.length > 0) {
                const lastAction = actionHistory.pop();
                console.log("Undoing action:", lastAction);
                
                if (lastAction.type === 'delete') {
                    // Undo a deletion - restore the name
                    const nameToRestore = lastAction.name;
                    
                    // Add back to custom names if it was a custom name
                    if (lastAction.wasCustom) {
                        customNames.push(nameToRestore);
                    }
                    
                    // Create and add the name element back
                    const nameElement = createNameElement(nameToRestore);
                    const namePool = document.querySelector('.name-pool');
                    namePool.appendChild(nameElement);
                    
                    console.log(`Restored deleted name: ${nameToRestore}`);
                    
                } else if (lastAction.type === 'add') {
                    // Undo an addition - remove the added names
                    lastAction.names.forEach(nameToRemove => {
                        console.log(`Removing name: ${nameToRemove}`);
                        
                        // Remove from custom names array
                        const customIndex = customNames.indexOf(nameToRemove);
                        if (customIndex > -1) {
                            customNames.splice(customIndex, 1);
                            console.log(`Removed ${nameToRemove} from customNames`);
                        }
                        
                        // Remove from DOM
                        const elementToRemove = [...document.querySelectorAll('.name-item')]
                            .find(item => item.textContent === nameToRemove);
                        if (elementToRemove) {
                            elementToRemove.remove();
                            console.log(`Removed ${nameToRemove} from DOM`);
                        } else {
                            console.log(`Could not find element for ${nameToRemove}`);
                        }
                    });
                    
                    console.log(`Removed added names: ${lastAction.names.join(', ')}`);
                    
                } else if (lastAction.type === 'move') {
                    // Undo a move - restore the name to its original position
                    const nameToMove = lastAction.name;
                    
                    // Find the name element
                    const nameElement = [...document.querySelectorAll('.name-item')]
                        .find(item => item.textContent === nameToMove);
                    
                    if (nameElement) {
                        let targetContainer;
                        
                        // Find the target container to restore to
                        if (lastAction.from === 'POOL') {
                            targetContainer = document.querySelector('.name-pool');
                        } else {
                            targetContainer = document.querySelector(`[data-tier="${lastAction.from}"]`);
                        }
                        
                        if (targetContainer) {
                            // Get all name items in the target container
                            const existingItems = [...targetContainer.querySelectorAll('.name-item')];
                            
                            // Insert at the original position
                            if (lastAction.fromPosition >= existingItems.length) {
                                targetContainer.appendChild(nameElement);
                            } else {
                                const referenceItem = existingItems[lastAction.fromPosition];
                                if (referenceItem) {
                                    targetContainer.insertBefore(nameElement, referenceItem);
                                } else {
                                    targetContainer.appendChild(nameElement);
                                }
                            }
                            
                            console.log(`Moved ${nameToMove} back to ${lastAction.from} at position ${lastAction.fromPosition}`);
                        }
                    }
                    
                } else if (lastAction.type === 'reset') {
                    // Undo a reset - restore all names to their original positions
                    lastAction.moves.forEach(moveData => {
                        const nameElement = [...document.querySelectorAll('.name-item')]
                            .find(item => item.textContent === moveData.name);
                        
                        if (nameElement) {
                            let targetContainer = document.querySelector(`[data-tier="${moveData.from}"]`);
                            
                            if (targetContainer) {
                                // Get existing items in target container
                                const existingItems = [...targetContainer.querySelectorAll('.name-item')];
                                
                                // Insert at original position
                                if (moveData.fromPosition >= existingItems.length) {
                                    targetContainer.appendChild(nameElement);
                                } else {
                                    const referenceItem = existingItems[moveData.fromPosition];
                                    if (referenceItem) {
                                        targetContainer.insertBefore(nameElement, referenceItem);
                                    } else {
                                        targetContainer.appendChild(nameElement);
                                    }
                                }
                            }
                        }
                    });
                    
                    console.log(`Restored ${lastAction.moves.length} names from reset`);
                }
                
                // Save changes to localStorage
                saveToLocalStorage();
            } else {
                console.log("Nothing to undo");
            }
        }

        function loadNames() {
            const namePool = document.querySelector('.name-pool');
            // Clear existing names except the header
            const headerContainer = namePool.querySelector('.name-pool-header');
            namePool.innerHTML = '';
            namePool.appendChild(headerContainer);
            
            // Add DELETE button positioned at same level as 2028s text (far left)
            const deleteBtn = document.createElement('div');
            deleteBtn.innerHTML = 'DELETE';
            deleteBtn.style.cssText = 'position: absolute; top: 20px; left: 20px; background: red; color: white; padding: 10px 16px; border-radius: 5px; font-weight: bold; font-size: 16px; cursor: pointer; z-index: 2; transition: all 0.3s ease;';
            deleteBtn.ondrop = dropOnDelete;
            deleteBtn.ondragover = allowDropOnDelete;
            deleteBtn.ondragleave = removeDeleteHover;
            namePool.appendChild(deleteBtn);
            
            // Add UNDO button (right next to DELETE button)
            const undoBtn = document.createElement('div');
            undoBtn.innerHTML = 'UNDO';
            undoBtn.style.cssText = 'position: absolute; top: 20px; left: 120px; background: #666; color: white; padding: 10px 16px; border-radius: 5px; font-weight: bold; font-size: 16px; cursor: pointer; z-index: 2;';
            undoBtn.onclick = undoDelete;
            namePool.appendChild(undoBtn);
            
            // Add ADD button on the right side (green)
            const addBtn = document.createElement('div');
            addBtn.className = 'add-btn';
            addBtn.innerHTML = 'ADD';
            addBtn.style.cssText = 'position: absolute; top: 20px; right: 20px; background: green; color: white; padding: 10px 16px; border-radius: 5px; font-weight: bold; font-size: 16px; cursor: pointer; z-index: 2;';
            addBtn.onclick = addNewName;
            namePool.appendChild(addBtn);
            
            // Load both original and custom names
            getAllNames().forEach(name => {
                const nameElement = createNameElement(name);
                namePool.appendChild(nameElement);
            });
        }

        function createNameElement(name) {
            const div = document.createElement('div');
            div.className = 'name-item';
            div.draggable = true;
            div.textContent = name;
            div.ondragstart = drag;
            return div;
        }

        function drag(event) {
            event.dataTransfer.setData("text", event.target.textContent);
            event.target.classList.add('dragging');
            
            // Remove dragging class after drag ends
            setTimeout(() => {
                event.target.classList.remove('dragging');
            }, 100);
        }

        function allowDrop(event) {
            event.preventDefault();
            const container = event.currentTarget;
            if (!container.classList.contains('tier-items') && !container.classList.contains('name-pool')) {
                return;
            }
            container.classList.add('drag-over');
            
            // Add glow indicators for tier items
            if (container.classList.contains('tier-items')) {
                requestAnimationFrame(() => updateGlowIndicators(container, event));
            }
        }
        
        function updateGlowIndicators(container, event) {
            // Remove existing glows from ALL containers first
            document.querySelectorAll('.tier-items .name-item').forEach(item => {
                item.classList.remove('glow-left', 'glow-right');
            });
            
            const mouseX = event.clientX;
            const mouseY = event.clientY;
            const containerRect = container.getBoundingClientRect();
            
            const existingItems = [...container.querySelectorAll('.name-item')];
            
            if (existingItems.length === 0) return;
            
            // Group items by rows first
            const itemsByRow = [];
            let currentRow = [];
            let currentRowY = null;
            
            existingItems.forEach(item => {
                const itemRect = item.getBoundingClientRect();
                const itemY = Math.round(itemRect.top);
                
                if (currentRowY === null || Math.abs(itemY - currentRowY) < 10) {
                    // Same row (within 10px tolerance)
                    currentRow.push(item);
                    currentRowY = itemY;
                } else {
                    // New row
                    if (currentRow.length > 0) {
                        itemsByRow.push(currentRow);
                    }
                    currentRow = [item];
                    currentRowY = itemY;
                }
            });
            
            if (currentRow.length > 0) {
                itemsByRow.push(currentRow);
            }
            
            // Find which row the mouse is closest to
            let targetRow = null;
            let closestRowDistance = Infinity;
            
            itemsByRow.forEach(row => {
                const firstItem = row[0];
                const itemRect = firstItem.getBoundingClientRect();
                const rowY = itemRect.top + itemRect.height / 2;
                const distance = Math.abs(mouseY - rowY);
                
                if (distance < closestRowDistance) {
                    closestRowDistance = distance;
                    targetRow = row;
                }
            });
            
            if (!targetRow) return;
            
            // Within the target row, find the closest item horizontally
            let closestItem = null;
            let closestDistance = Infinity;
            let insertBefore = false;
            
            targetRow.forEach(item => {
                const itemRect = item.getBoundingClientRect();
                const itemCenterX = itemRect.left + itemRect.width / 2;
                const distance = Math.abs(mouseX - itemCenterX);
                
                if (distance < closestDistance) {
                    closestDistance = distance;
                    closestItem = item;
                    insertBefore = mouseX < itemCenterX;
                }
            });
            
            if (closestItem) {
                const closestIndex = existingItems.indexOf(closestItem);
                
                if (insertBefore) {
                    closestItem.classList.add('glow-left');
                    if (closestIndex > 0) {
                        existingItems[closestIndex - 1].classList.add('glow-right');
                    }
                } else {
                    closestItem.classList.add('glow-right');
                    if (closestIndex < existingItems.length - 1) {
                        existingItems[closestIndex + 1].classList.add('glow-left');
                    }
                }
            }
        }

        function drop(event) {
            event.preventDefault();
            const data = event.dataTransfer.getData("text");
            const container = event.currentTarget;
            
            // Clean up all containers
            document.querySelectorAll('.tier-items, .name-pool').forEach(item => {
                item.classList.remove('drag-over');
                // Remove glow effects
                item.querySelectorAll('.name-item').forEach(nameItem => {
                    nameItem.classList.remove('glow-left', 'glow-right');
                });
            });
            
            // Find the dragged element
            const draggedElement = [...document.querySelectorAll('.name-item')]
                .find(item => item.textContent === data);
            
            if (!draggedElement) return;
            
            // Record the current position before moving (for undo functionality)
            const nameText = draggedElement.textContent;
            let fromLocation = 'POOL'; // default
            let fromPosition = -1;
            
            // Find where the element is currently located
            const currentParent = draggedElement.parentElement;
            if (currentParent.classList.contains('tier-items')) {
                fromLocation = currentParent.dataset.tier;
                fromPosition = [...currentParent.querySelectorAll('.name-item')].indexOf(draggedElement);
            } else if (currentParent.classList.contains('name-pool')) {
                fromLocation = 'POOL';
                fromPosition = [...currentParent.querySelectorAll('.name-item')].indexOf(draggedElement);
            }
            
            if (container.classList.contains('name-pool')) {
                const toPosition = container.querySelectorAll('.name-item').length;
                
                // Add to action history for undo
                actionHistory.push({
                    type: 'move',
                    name: nameText,
                    from: fromLocation,
                    fromPosition: fromPosition,
                    to: 'POOL',
                    toPosition: toPosition
                });
                
                container.appendChild(draggedElement);
                // Add dropped glow effect
                addDroppedGlow(draggedElement);
                // Save positions to localStorage
                saveToLocalStorage();
                return;
            }
            
            if (container.classList.contains('tier-items')) {
                const mouseX = event.clientX;
                const mouseY = event.clientY;
                
                const existingItems = [...container.querySelectorAll('.name-item')]
                    .filter(item => item !== draggedElement);
                
                let finalPosition = 0; // default position
                
                // If no existing items, just append
                if (existingItems.length === 0) {
                    finalPosition = 0;
                    container.appendChild(draggedElement);
                } else {
                    // Group items by rows first
                    const itemsByRow = [];
                    let currentRow = [];
                    let currentRowY = null;
                    
                    existingItems.forEach(item => {
                        const itemRect = item.getBoundingClientRect();
                        const itemY = Math.round(itemRect.top);
                        
                        if (currentRowY === null || Math.abs(itemY - currentRowY) < 10) {
                            currentRow.push(item);
                            currentRowY = itemY;
                        } else {
                            if (currentRow.length > 0) {
                                itemsByRow.push(currentRow);
                            }
                            currentRow = [item];
                            currentRowY = itemY;
                        }
                    });
                    
                    if (currentRow.length > 0) {
                        itemsByRow.push(currentRow);
                    }
                    
                    // Find which row the mouse is closest to vertically
                    let targetRow = null;
                    let closestRowDistance = Infinity;
                    
                    itemsByRow.forEach(row => {
                        const firstItem = row[0];
                        const itemRect = firstItem.getBoundingClientRect();
                        const rowY = itemRect.top + itemRect.height / 2;
                        const distance = Math.abs(mouseY - rowY);
                        
                        if (distance < closestRowDistance) {
                            closestRowDistance = distance;
                            targetRow = row;
                        }
                    });
                    
                    if (!targetRow) {
                        finalPosition = existingItems.length;
                        container.appendChild(draggedElement);
                    } else {
                        // Within the target row, find insertion point horizontally
                        let insertBefore = null;
                        
                        for (let item of targetRow) {
                            const itemRect = item.getBoundingClientRect();
                            const itemCenterX = itemRect.left + itemRect.width / 2;
                            
                            if (mouseX < itemCenterX) {
                                insertBefore = item;
                                break;
                            }
                        }
                        
                        if (insertBefore) {
                            finalPosition = existingItems.indexOf(insertBefore);
                            container.insertBefore(draggedElement, insertBefore);
                        } else {
                            // Insert after the last item in the target row
                            const lastItemInRow = targetRow[targetRow.length - 1];
                            const lastItemIndex = existingItems.indexOf(lastItemInRow);
                            const nextItem = existingItems[lastItemIndex + 1];
                            
                            if (nextItem) {
                                finalPosition = existingItems.indexOf(nextItem);
                                container.insertBefore(draggedElement, nextItem);
                            } else {
                                finalPosition = existingItems.length;
                                container.appendChild(draggedElement);
                            }
                        }
                    }
                }
                
                // Add to action history for undo
                actionHistory.push({
                    type: 'move',
                    name: nameText,
                    from: fromLocation,
                    fromPosition: fromPosition,
                    to: container.dataset.tier,
                    toPosition: finalPosition
                });
                
                addDroppedGlow(draggedElement);
                // Save positions to localStorage
                saveToLocalStorage();
            }
        }

        function addDroppedGlow(element) {
            // Remove any existing dropped glow from all elements
            document.querySelectorAll('.name-item').forEach(item => {
                item.classList.remove('dropped-glow');
            });
            
            // Add glow to the dropped element
            element.classList.add('dropped-glow');
            
            // Remove glow after 0.5 seconds
            setTimeout(() => {
                element.classList.remove('dropped-glow');
            }, 500);
        }

        // Remove drag-over class when drag leaves
        document.addEventListener('dragleave', function(event) {
            // Only remove if truly leaving the element
            const related = event.relatedTarget;
            if (!related || (!event.target.contains(related) && event.target !== related)) {
                if (event.target.classList.contains('tier-items') || event.target.classList.contains('name-pool')) {
                    event.target.classList.remove('drag-over');
                    // Remove glow effects
                    event.target.querySelectorAll('.name-item').forEach(item => {
                        item.classList.remove('glow-left', 'glow-right');
                    });
                }
            }
        });

        document.addEventListener('dragend', function(event) {
            // Clean up all drag states
            document.querySelectorAll('.tier-items, .name-pool').forEach(item => {
                item.classList.remove('drag-over');
                // Remove glow effects
                item.querySelectorAll('.name-item').forEach(nameItem => {
                    nameItem.classList.remove('glow-left', 'glow-right');
                });
            });
            
            // Remove dragging class from name items
            document.querySelectorAll('.name-item').forEach(item => {
                item.classList.remove('dragging');
            });
        });

        function resetTiers() {
            // Record all current positions for undo functionality
            const moveActions = [];
            
            document.querySelectorAll('.tier-items').forEach(tierContainer => {
                const tier = tierContainer.dataset.tier;
                const nameElements = [...tierContainer.querySelectorAll('.name-item')];
                
                nameElements.forEach((element, index) => {
                    moveActions.push({
                        name: element.textContent,
                        from: tier,
                        fromPosition: index,
                        to: 'POOL'
                    });
                });
            });
            
            // If there were moves, add a batch reset action to history
            if (moveActions.length > 0) {
                actionHistory.push({
                    type: 'reset',
                    moves: moveActions
                });
            }
            
            const allNameElements = document.querySelectorAll('.name-item');
            const namePool = document.querySelector('.name-pool');
            
            allNameElements.forEach(element => {
                namePool.appendChild(element);
            });
            
            // Save the reset state to localStorage
            saveToLocalStorage();
        }

        function shuffleNames() {
            const namePool = document.querySelector('.name-pool');
            const nameElements = [...namePool.querySelectorAll('.name-item')];
            
            // Shuffle array
            for (let i = nameElements.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [nameElements[i], nameElements[j]] = [nameElements[j], nameElements[i]];
            }
            
            // Clear and re-add shuffled elements - need to reload everything
            loadNames();
            
            // Re-add shuffled name elements
            nameElements.forEach(element => {
                const namePool = document.querySelector('.name-pool');
                namePool.appendChild(element);
            });
            
            // Save the shuffled state to localStorage
            saveTierPositions();
        }

        function clearAllData() {
            if (confirm('Are you sure you want to clear all saved data? This will remove all custom names and reset all tier positions.')) {
                // Clear localStorage
                localStorage.removeItem(STORAGE_KEYS.CUSTOM_NAMES);
                localStorage.removeItem(STORAGE_KEYS.TIER_POSITIONS);
                localStorage.removeItem(STORAGE_KEYS.ACTION_HISTORY);
                
                // Reset in-memory data
                customNames = [];
                actionHistory = [];
                
                // Reload the page to original state
                loadNames();
                
                alert('All data has been cleared!');
            }
        }

        function downloadImage() {
            const button = event.target;
            const originalText = button.textContent;
            button.textContent = 'Generating...';
            button.disabled = true;
            
            // Hide controls and name pool during capture
            const controls = document.querySelector('.controls');
            const namePool = document.querySelector('.name-pool');
            controls.style.display = 'none';
            namePool.style.display = 'none';
            
            // Wait a moment for the DOM to update
            setTimeout(() => {
                html2canvas(document.querySelector('.container'), {
                    backgroundColor: '#2a2a2a',
                    scale: 2,
                    useCORS: true,
                    allowTaint: false,
                    scrollX: 0,
                    scrollY: 0,
                    width: document.querySelector('.container').offsetWidth,
                    height: document.querySelector('.container').offsetHeight,
                    logging: false,
                    removeContainer: true
                }).then(canvas => {
                    // Show controls and name pool again
                    controls.style.display = 'flex';
                    namePool.style.display = 'flex';
                    
                    try {
                        // Create download link
                        const link = document.createElement('a');
                        link.download = 'my-tier-list.png';
                        link.href = canvas.toDataURL('image/png', 1.0);
                        
                        // Trigger download
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                        
                        // Reset button
                        button.textContent = originalText;
                        button.disabled = false;
                    } catch (downloadError) {
                        console.error('Download error:', downloadError);
                        // Fallback: open image in new tab
                        const newWindow = window.open();
                        newWindow.document.write('<img src="' + canvas.toDataURL() + '" alt="Tier List"/>');
                        
                        button.textContent = originalText;
                        button.disabled = false;
                        alert('Image opened in new tab. Right-click to save!');
                    }
                }).catch(error => {
                    console.error('Canvas error:', error);
                    
                    // Show controls and name pool again and reset button
                    controls.style.display = 'flex';
                    namePool.style.display = 'flex';
                    button.textContent = originalText;
                    button.disabled = false;
                    
                    alert('Image capture failed. Please use your browser\'s screenshot feature instead.');
                });
            }, 100);
        }
    </script>
</body>
</html>
